{
    "name": "Ã…",
    "scopeName": "source.aa",
    "patterns": [
      { "include": "#pre-processing" },
      { "include": "#comment" },
      { "include": "#declerations" },
      { "include": "#directives" }
    ],
    "repository": {
      "declerations": {
        "patterns": [
          { "include": "#namespace-decleration" },
          { "include": "#class-decleration" },
          { "include": "#function-decleration" }
        ]
      },
      "class-members": {
        "patterns": [
          { "include": "#class-decleration" },
          { "include": "#function-decleration" },
          { "include": "#constructor-decleration" }
        ]
      },
      "directives": {
        "patterns": [
          { "include": "#using-directive" }
        ]
      },
      "statement": {
        "patterns": [
          { "include": "#if-statement" },
          { "include": "#for-statement" },
          { "include": "#while-statement" },
          { "include": "#new-statement" }
        ]
      },
      "expression": {
        "patterns": [
        ]
      },
      "comment": {
        "begin": "//",
        "end": "\n",
        "name": "comment"
      },
      "using-directive": {
        "patterns": [
          {
            "begin": "\\b(using)\\s+\\S+\\s+(from)\\s+",
            "beginCaptures": {
              "1": {
                "name": "keyword.other.using"
              },
              "2": {
                "name": "keyword.other.using"
              }
            },
            "end": "(?=;)",
            "patterns": [
              {
                "include": "#comment"
              },
              {
                "name": "entity.name.type",
                "match": "@?[_[:alpha:]][_[:alnum:]]*"
              }
            ]
          },
          {
            "begin": "\\b(using)\\s+",
            "beginCaptures": {
              "1": {
                "name": "keyword.other.using"
              }
            },
            "end": "(?=;)",
            "patterns": [
              {
                "include": "#comment"
              },
              {
                "name": "entity.name.type",
                "match": "@?[_[:alpha:]][_[:alnum:]]*"
              }
            ]
          }
        ]
      },
      "namespace-decleration": {
        "begin": "\\b(namespace)\\s+",
        "beginCaptures": {
          "1": {
            "name": "keyword.word"
          }
        },
        "end": "(?<=\\})",
        "patterns": [
          {
            "include": "#comment"
          },
          {
            "name": "entity.name.type",
            "match": "@?[_[:alpha:]][_[:alnum:]]*"
          },
          {
            "begin": "\\{",
            "beginCaptures": {
              "0": {
                "name": "punctuation.curlybrace.open.cs"
              }
            },
            "end": "\\}",
            "endCaptures": {
              "0": {
                "name": "punctuation.curlybrace.close.cs"
              }
            },
            "patterns": [
              {
                "include": "#declerations"
              },
              {
                "include": "#expression"
              }
            ]
          }
        ]
      },
      "class-decleration": {
        "begin": "(?=\\bclass\\b)",
        "beginCaptures": {
          "1": {
            "name": "keyword.word"
          }
        },
        "end": "(?<=\\})",
        "patterns": [
          {
            "begin": "(?x)\n\\b(class)\\b\\s+\n(@?[_[:alpha:]][_[:alnum:]]*)\\s*",
            "beginCaptures": {
              "1": {
                "name": "keyword.other.class.cs"
              },
              "2": {
                "name": "entity.name.type.class.cs"
              }
            },
            "end": "(?=\\{)",
            "patterns": [
              {
                "include": "#comment"
              }
            ]
          },
          {
            "begin": "\\{",
            "beginCaptures": {
              "0": {
                "name": "punctuation.curlybrace.open.cs"
              }
            },
            "end": "\\}",
            "endCaptures": {
              "0": {
                "name": "punctuation.curlybrace.close.cs"
              }
            },
            "patterns": [
              {
                "include": "#class-members"
              }
            ]
          },
          {
            "include": "#comment"
          }
        ]
      },
      "function-decleration": {
        "begin": "(?x)\n(?<return-type>\n  (?<type-name>\n(?:\n      (?:ref\\s+(?:readonly\\s+)?)?   # ref return\n      (?:\n        (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n        (?<name-and-type-args> # identifier + type arguments (if any)\n          \\g<identifier>\\s*\n          (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?\n        )\n        (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?\n        (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n      )\n      (?:\\s*\\?\\s*)? # nullable suffix?\n      (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?\n    )\n  )\\s+\n)\n(?<interface-name>\\g<type-name>\\s*\\.\\s*)?\n(\\g<identifier>)\\s*\n(<([^<>]+)>)?\\s*\n(?=\\()",
        "beginCaptures": {
          "1": {
            "patterns": [
              {
                "include": "#type"
              }
            ]
          },
          "8": {
            "name": "entity.name.function.cs"
          }
        },
        "end": "(?<=\\})|(?=;)",
        "patterns": [
          {
            "include": "#comment"
          },
          {
            "include": "#parenthesized-parameter-list"
          },
          {
            "include": "#generic-constraints"
          },
          {
            "include": "#expression-body"
          },
          {
            "include": "#block"
          }
        ]
      },
      "type": {
        "name": "meta.type.cs",
        "patterns": [
          {
            "include": "#comment"
          },
          {
            "include": "#type-builtin"
          }
        ]
      },
      "type-builtin": {
        "match": "\\b(bool|char|double|float|int|string|void)\\b",
        "captures": {
          "1": {
            "name": "keyword.type.cs"
          }
        }
      }
    }
}
